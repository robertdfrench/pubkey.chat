#!/usr/bin/env python3
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
# Copyright 2024 Robert D. French
"""
The Web-based Message Authentication Protocol

WMAP allows secure exchange of signed messages between users using their GitHub
SSH keys. This tool allows you to sign, verify, and extract messages.

Key features:
- Sign messages using SSH keys linked to GitHub accounts
- Verify the authenticity and integrity of signed messages
- Extract the content of signed messages

This module implements the core functionality of WMAP, including command-line
interface, cryptographic operations, and file handling.
"""
import argparse
import base64
import configparser
import curses
from dataclasses import dataclass
from enum import Enum, auto
import hashlib
import json
from typing import List
import os
from urllib import request
import subprocess
import sys
import tempfile
import threading
import time


# This is the SSH signing namespace that we use for wmap messages. This is to
# distinguish WMAP signatures from other SSH signin functions, as encouraged by
# the ssh-keygen(1) man page.
NAMESPACE = "wmap@wmap.dev"


# This is the hardcoded base URL for the pubkey.chat service. This will need to
# be configured, in the future, to default to `pubkey.chat` but also be
# overridable for the sake of testing.
API_BASE_URL = "https://oe9xunloch.execute-api.us-east-1.amazonaws.com/prod"


def main():  # pragma: no cover
    """
    Application entrypoint.

    This is the application entrypoint (called at the end of this file in
    the traditional python fashion). It assembles the command line interface
    via argparse, and then passes control to one of the subcommand functions.

    Subcommands:
    - sign: Sign a file using your GitHub username and SSH key
    - verify: Verify the authenticity of a signed file
    - extract: Extract the content of a signed file, with an option to skip
      validation

    QA note: This function is not covered in unit testing as it is part of the
    user interface.
    """
    # Setup the command line argument parser.
    #
    # This parser will read the comand line arguments provided by the user and
    # turn them into a structure that we can query. This will allow us to
    # determine what actions to perform later on.
    #
    # If you have not worked with argparse before, check out the tutorial:
    # https://docs.python.org/3/howto/argparse.html#argparse-tutorial
    parser = argparse.ArgumentParser(
            description='pubkey.chat: Signed communication via GitHub keys')
    subparsers = parser.add_subparsers(dest='command', help='sub-command help')

    # Setup subparser for the 'chat' command
    parser_chat = subparsers.add_parser(
            'chat', help='Chat with other GitHub users')
    parser_chat.add_argument(
            'username', type=str, help='GitHub username')
    parser_chat.add_argument(
            'key', type=str, help='SSH private key to use for chatting')
    parser_chat.add_argument(
            'topic', type=str, help='Chat Topic')

    # Setup subparser for the 'extract' command
    parser_extract = subparsers.add_parser(
            'extract', help='Extract a signed file')
    parser_extract.add_argument(
            '--skip-validation', action='store_true',
            help='Something is very wrong if you need to use this flag')
    parser_extract.add_argument(
            'file', type=str, help='Signed file to be extracted')

    # Setup subparser for the 'service' command
    parser_service = subparsers.add_parser(
            'service', help='validate incoming messages')
    parser_service.add_argument(
            'config', type=str, help='Path to config file')

    # Setup subparser for the 'sign' command
    parser_sign = subparsers.add_parser(
            'sign', help='Sign a file')
    parser_sign.add_argument(
            'username', type=str, help='GitHub username')
    parser_sign.add_argument(
            'key', type=str, help='SSH private key to use for signing')
    parser_sign.add_argument(
            'file', type=str, help='File to be signed')

    # Setup subparser for the 'verify' command
    parser_verify = subparsers.add_parser(
            'verify', help='Verify a signed file')
    parser_verify.add_argument(
            'file', type=str, help='Signed file to be verified')

    args = parser.parse_args()

    # Call the appropriate function based on the subcommand. Each subcommand is
    # handled by its own function, and each expects different arguments.
    if args.command == 'chat':
        chat_cmd(args.username, args.key, args.topic)
    elif args.command == 'extract':
        extract_cmd(args.file, args.skip_validation)
    elif args.command == 'service':
        service_cmd(args.config)
    elif args.command == 'sign':
        sign_cmd(args.username, args.key, args.file)
    elif args.command == 'verify':
        verify_cmd(args.file)
    else:
        parser.print_help()


def chat_cmd(username: str, key: str, topic: str):  # pragma: no cover
    """
    Open a chat window for 'topic'

    Parameters:
    - username: Your GitHub username
    - key: Path to your SSH private key
    - topic: The room you'd like to join
    """
    def chat_main(stdscr):
        user = SessionUser(username, key, topic)
        session = ChatSession(stdscr, user)

        def update_messages():
            while True:
                session.update_messages()
                time.sleep(2)

        comms_thread = threading.Thread(target=update_messages)
        comms_thread.daemon = True
        comms_thread.start()

        while True:
            session.redraw()
            session.check_input()
            time.sleep(0.016)

    curses.wrapper(chat_main)


def extract_cmd(file: str, skip_validation: bool = False):  # pragma: no cover
    """
    Verify, decode, and print the body of a WMAP-formatted file.

    Parameters:
    - file: the path to a WMAP-formatted file
    - skip_validation: allow wmap to extract the body from an invalid file.

    QA note: This function is not covered in unit testing as it is part of the
    user interface.
    """
    if not skip_validation:  # Read this as 'if validate == True'
        verify_cmd(file)
    # If the message has a good signature, extract and print the body
    message = SignedMessage.load(file)
    print(str(message.body, 'utf-8'))


def service_cmd(config_path: str):  # pragma: no cover
    """
    Launch the chat service

    Parameters:
    - config_path: path to the chat service's config file

    The config file should spell out the AWS Region ('region'), name of an S3
    bucket into which messages will be written ('bucket_name'), and the name of
    an SQS queue from which messages will be pulled ('queue_name').
    """
    config = configparser.ConfigParser()
    config.read(config_path)
    s3 = S3Wrapper(
        config['DEFAULT']['region'],
        config['DEFAULT']['bucket_name']
    )
    bucket = PublicChatBucket(s3)
    sqs = SQSWrapper(
        config['DEFAULT']['region'],
        config['DEFAULT']['queue_name']
    )
    queue = Queue(sqs)
    for message in queue.messages():
        if message.is_valid():
            bucket.write_message(message)


def sign_cmd(username: str, key: str, file: str):  # pragma: no cover
    """
    Sign a file using the specified GitHub username and SSH key.

    This function creates a WMAP-formatted, signed version of the input file.

    Parameters:
    - username: The GitHub username of the file's author
    - key: Path to the SSH private key of the author
    - file: Path to the file being signed

    Output:
    - Creates a new file named '{file}.wmap' containing the signed message.

    Note: The public key corresponding to the private key must be installed on
    the author's GitHub account.
    """
    profile = Profile(username)             # Load *your* github Profile
    private_key = PrivateKey(profile, key)  # Load *your* SSH Private Key
    private_key.sign(file)                  # Sign `file` with your SSH key
    message = SignedMessage.from_raw_parts(
            profile, file)                  # Load everything into one object
    message.dump(file + ".wmap")            # Write WMAP-formatted msg to disk
    os.remove(file + ".sig")                # Remove temporary sig file


def verify_cmd(file: str):  # pragma: no cover
    """
    Verify the signature of a WMAP-formatted file.

    Parameters:
    - file: the path to a WMAP-formatted file

    If the file cannot be verified, this function will cause wmap to exit
    nonzero.

    QA note: This function is not covered in unit testing as it is part of the
    user interface.
    """
    sigfile = file + ".sig"
    message = SignedMessage.load(file)     # Load message from disk
    message.signature.dump(sigfile)  # Extract signature temporarily
    valid = message.profile.verify_signed_data(
            message.body, sigfile)   # Check signature against profile & body
    os.remove(sigfile)               # Remove temporary signature
    if not valid:
        print("This document is not valid", file=sys.stderr)
        sys.exit(1)


class SigningAlgorithm(Enum):
    """
    Allowable algorithms for SSH signing keys.

    Not all SSH key algorithms support signing. RSA and ED25519 do, so when
    parsing an Allowed Signers record or an Authorized Key record, we want to
    restrict ourselves to those two algorithms.
    """
    RSA = auto()
    ED25519 = auto()

    @classmethod
    def parse(cls, string: str) -> 'SigningAlgorithm':
        """
        Attempt to parse a string into one of these SigningAlgorithm enum
        instances.

        Parameters:
        - string: a string which may or may not be a valid SSH signing
          algorithm.

        Raises:
        - Exception: if the string does not match an allowed algorithm.
        """
        if string == "ssh-rsa":
            return cls.RSA
        elif string == "ssh-ed25519":
            return cls.ED25519
        else:
            raise Exception("Unknown ssh key algorithm")

    def __str__(self):
        if self == SigningAlgorithm.RSA:
            return "ssh-rsa"
        if self == SigningAlgorithm.ED25519:
            return "ssh-ed25519"


@dataclass
class AuthorizedKey:
    """
    Representation of an Authorized Key entry, as seen in an
    ~/.ssh/authorized_keys file.

    See the AUTHORIZED_KEYS_FILE_FORMAT section of the sshd(8) man page for
    more information about what these files look like.
    """
    algorithm: SigningAlgorithm
    material: str
    comment: str

    @classmethod
    def parse(cls, string: str) -> 'AuthorizedKey':
        """
        Parse an authorized keys entry into its constituent parts. Such entries
        take the following form:

            ssh-rsa ABC...123 username@example.com (other comments)

        Parameters:
        - string: a string which ought to be a normal-looking authorized keys
          entry.
        """
        parts = string.split()
        algorithm = SigningAlgorithm.parse(parts[0])
        return cls(algorithm, parts[1], " ".join(parts[2:]))

    def into_allowed_signer(self, profile: 'Profile') -> str:
        """
        Convert this authorized keys entry into an ALLOWED SIGNERS entry. Such
        records take the following form:

            username namespacs="wmap@wmap.dev" ssh-rsa ABC...123

        More information on ALLOWED SIGNERS can be found in the `ssh-keygen(1)`
        manual page.

        Parameters:
        - profile: the profile of the GitHub user for whom we'd like to build
          the ALLOWED SIGNERS record.
        """
        principal = profile.username
        algorithm = str(self.algorithm)
        material = self.material
        return f"{principal} namespaces=\"{NAMESPACE}\" {algorithm} {material}"


@dataclass
class PublicChatBucket:
    s3: 'S3Wrapper'

    def write_message(self, msg: 'SignedMessage'):
        msg_id = msg.digest()
        self.s3.write(f"/messages/{msg_id}", msg.dumps())
        interior = msg.interior()
        head = self.s3.read(f"/topics/{interior.topic}")
        if not head:
            self.s3.write(f"/topics/{interior.topic}", msg_id)
        if interior.parent == head:
            self.s3.write(f"/topics/{interior.topic}", msg_id)


@dataclass
class ChatAPIClient:
    """
    Raw operations with the Chat Service backend
    """
    api_base_url: str
    rest_client: 'RestClient'

    def get_message(self, message_id: str) -> 'SignedMessage':
        url = f"{self.api_base_url}/messages/{message_id}"
        msg_text = self.rest_client.get(url)
        return SignedMessage.loads(msg_text)

    def get_head(self, topic: str) -> str:
        url = f"{self.api_base_url}/topics/{topic}"
        return self.rest_client.get(url).rstrip()

    def post_message(self, message: 'SignedMessage') -> str:
        url = f"{self.api_base_url}/messages"
        payload = message.into_dict()
        message.dump("chat.wmap")
        return self.rest_client.post_json(url, payload)


class ChatSession:  # pragma: no cover
    def __init__(self, stdscr, user: 'SessionUser'):
        self.stdscr = stdscr
        self.user = user
        self.current_input = ""
        self.messages: list[str] = []
        self.parent = ""
        self.client = ChatAPIClient(API_BASE_URL, RestClient())

        curses.curs_set(0)  # Hide cursor
        stdscr.nodelay(1)  # Don't block when waiting for input
        stdscr.timeout(1000)  # Refresh every second

        self.messages_win = curses.newwin(curses.LINES - 3, curses.COLS, 0, 0)
        self.input_win = curses.newwin(3, curses.COLS, curses.LINES - 3, 0)

        self.input_win.addstr(1, 1, "> ")
        self.input_win.refresh()

    def post_message(self, text):
        interior = dict()
        interior['topic'] = self.user.topic
        interior['parent'] = self.parent
        interior['data'] = text
        with tempfile.NamedTemporaryFile() as f:
            f.write(bytes(json.dumps(interior), 'utf-8'))
            f.flush()
            sign_cmd(self.user.username, self.user.key, f.name)
            msg = SignedMessage.load(f.name + ".wmap")
            self.client.post_message(msg)

    def update_messages(self):
        parent = self.client.get_head(self.user.topic)
        if parent != self.parent:
            self.parent = parent
            msg = self.client.get_message(parent)
            interior = json.loads(msg.body.decode())
            self.messages.append(
                msg.profile.username + ": " + interior['data']
            )

    def redraw(self):
        self.messages_win.clear()
        self.input_win.clear()
        self.input_win.addstr(1, 1, f"> {self.current_input}")
        for i, msg in enumerate(self.messages[-(curses.LINES - 3):]):
            self.messages_win.addstr(i, 0, msg)
        self.messages_win.refresh()
        self.input_win.refresh()

    def check_input(self):
        key = self.stdscr.getch()
        if key == curses.KEY_RESIZE:
            # Resize windows if terminal size changes
            self.messages_win.resize(curses.LINES - 3, curses.COLS)
            self.input_win.resize(3, curses.COLS)
            self.input_win.mvwin(curses.LINES - 3, 0)
        elif key == ord('\n'):
            if self.current_input.strip():
                self.post_message(self.current_input.strip())
                self.current_input = ""
        elif key == 27:  # Escape key
            raise "escape"
        elif key == curses.KEY_BACKSPACE or key == 127:
            self.current_input = self.current_input[:-1]
        elif key != -1:
            self.current_input += chr(key)


@dataclass
class InteriorMessage:
    topic: str
    parent: str
    data: str


@dataclass
class SignedMessage:
    """
    A signed copy of the original content, which can be shared with and
    validated by anyone.
    """
    profile: 'Profile'
    body: bytes
    signature: 'Signature'

    @classmethod
    def from_raw_parts(cls, profile: 'Profile', path: str) -> 'SignedMessage':
        """
        Create a SignedMessage object from a file and its signature.

        Parameters:
        - profile: the GitHub profile of the user who signed this document
        - path: path to the document which was signed

        Assumptions:
        The document referenced by `path` should have been signed (using wmap)
        prior to calling this method. In particular, an OpenSSH-formatted
        signature file should exist on disk at `path`.sig.
        """
        with open(path, 'rb') as f:
            body = f.read()
        signature = Signature.load(path + ".sig")
        return cls(profile, body, signature)

    @classmethod
    def from_dict(cls, parts: dict[str, str]) -> 'SignedMessage':
        profile = Profile(parts['profile'])
        body = parts['body'].encode()
        signature = Signature(parts['signature'])
        return cls(profile, body, signature)

    @classmethod
    def load(cls, path: str) -> 'SignedMessage':
        """
        Load an existing JSON-formatted WMAP message from disk.

        Parameters:
        - path: path to the JSON-formatted WMAP message
        """
        with open(path) as f:
            return cls.loads(f.read())

    @classmethod
    def loads(cls, data: str) -> 'SignedMessage':
        """
        Load an existing JSON-formatted WMAP message from disk.

        Parameters:
        - path: path to the JSON-formatted WMAP message
        """
        d = json.loads(data)
        profile = Profile(d['profile'])
        signature = Signature(d['signature'])
        body = base64.b64decode(d['body'])
        return cls(profile, body, signature)

    def into_dict(self) -> dict[str, str]:
        """
        Convert this object into a python dictionary, and convert each of its
        fields into their string representation.
        """
        return {
            'profile': str(self.profile),
            'body': str(base64.b64encode(self.body), 'utf-8'),
            'signature': str(self.signature)
        }

    def dump(self, path: str):
        """
        Store this message on disk.

        Parameters:
        - path: path on disk where this JSON-formatted WMAP message should be
          written.
        """
        with open(path, 'w') as f:
            json.dump(self.into_dict(), f)

    def dumps(self) -> str:
        """
        Convert this message to a json string
        """
        return json.dumps(self.into_dict())

    def is_valid(self) -> bool:
        with tempfile.NamedTemporaryFile() as sigfile:
            self.signature.dump(sigfile.name)
            sigfile.flush()
            return self.profile.verify_signed_data(self.body, sigfile.name)

    def interior(self) -> InteriorMessage:
        i = json.loads(self.body)
        return InteriorMessage(i['topic'], i['parent'], i['data'])

    def digest(self) -> str:
        digest = hashlib.sha256()
        digest.update(self.dumps().encode())
        return digest.hexdigest()


@dataclass
class Profile:
    """
    The GitHub profile associated with `username`
    """
    username: str

    def url(self) -> str:
        """URL for this user's github profile"""
        return f"https://github.com/{self.username}"

    def authorized_keys_url(self) -> str:
        """URL for this user's ssh public keys"""
        return self.url() + ".keys"

    def authorized_keys(self) -> List[AuthorizedKey]:
        """
        Grab the user's Authorized Keys from GitHub, transforming each of them
        into an AuthorizedKey object.
        """
        with request.urlopen(self.authorized_keys_url()) as response:
            lines = response.read().decode().splitlines()
            return [AuthorizedKey.parse(line) for line in lines]

    def allowed_signers(self) -> List[str]:
        """
        Transform each Authorized Key into an ALLOWED SIGNERS record

        More information on ALLOWED SIGNERS can be found in the `ssh-keygen(1)`
        manual page.
        """
        return [k.into_allowed_signer(self) for k in self.authorized_keys()]

    def verify_signed_data(self, data: bytes, signature_path: str) -> bool:
        """
        Check whether we have a valid signature for `data` from the current
        GitHub user.

        Parameters:
        - data: the bytes which were signed
        - signature_path: a path to the signature file created by ssh-keygen

        Returns true if the signature matches, false if not.
        """
        with tempfile.NamedTemporaryFile() as allowed_signers_file:
            signers = "\n".join(self.allowed_signers()) + "\n"
            # We write and flush together because we need to know for sure that
            # all these bytes have been written to disk before we try to point
            # ssh-keygen at this file.
            allowed_signers_file.write(bytes(signers, 'utf-8'))
            allowed_signers_file.flush()
            results = subprocess.run([
                'ssh-keygen', '-Y', 'verify',
                '-f', allowed_signers_file.name,  # This file was just flushed.
                '-I', self.username,
                '-n', NAMESPACE,
                '-s', signature_path
            ], input=data, capture_output=True)
            return results.returncode == 0

    def __str__(self) -> str:
        return self.username


@dataclass
class PrivateKey:
    """
    An SSH Private Key for the GitHub user identified by the `profile` object.
    """
    profile: Profile
    path: str

    def sign(self, file: str):
        """
        Use this private key to sign the contents of `file`.

        Parameters:
        - file: the file (on disk) which should be signed

        Upon success, the signature will be stored in `file`.sig.
        """
        subprocess.run([
            'ssh-keygen', '-Y', 'sign',
            '-f', self.path,
            '-n', NAMESPACE,
            file
        ], check=True)


@dataclass
class Queue():
    sqs: 'SQSWrapper'

    def messages(self):
        while True:
            candidates = self.sqs.receive(1)
            if len(candidates) == 0:  # pragma: no cover
                continue
            message = candidates[0]
            yield SignedMessage.from_dict(json.loads(message['Body']))
            self.sqs.delete(message['ReceiptHandle'])


@dataclass
class RestClient:  # pragma: no cover
    def get(self, url: str) -> str:
        with request.urlopen(url) as response:
            return response.read().decode()

    def post_json(self, url: str, payload: dict) -> str:
        data = json.dumps(payload).encode()
        headers = {'Content-Type': 'application/json'}
        r = request.Request(url, data=data, headers=headers, method='POST')
        with request.urlopen(r) as response:
            return response.read().decode()


class S3Wrapper:  # pragma: no cover
    def __init__(self, region, name):
        import boto3  # type: ignore
        self.client = boto3.client('s3', region_name=region)
        self.name = name

    def write(self, key: str, value: str):
        self.client.put_object(
            Bucket=self.name,
            Key=key,
            Body=value
        )

    def read(self, key: str) -> str:
        response = self.client.get_object(
            Bucket=self.name,
            Key=key
        )
        return response['Body'].read().decode()


@dataclass
class SessionUser:
    username: str
    key: str
    topic: str


@dataclass
class Signature:
    """
    The output of ssh-keygen -Y sign
    """
    content: str

    @classmethod
    def load(cls, path: str) -> 'Signature':
        """
        Load an SSH signature from a file

        Parameters:
        - path: path to an SSH signature file

        The SSH signature is stored on disk in a format determined by OpenSSH.
        This format is line-oriented, which is tricky to work with in a JSON
        document. As such, we choose to work with a base64-encoded
        representation of this signature instead.
        """
        with open(path) as f:
            raw_text = f.read()
            # Encode the signature bytes file as a Base64 string
            content = str(base64.b64encode(bytes(raw_text, 'utf-8')), 'utf-8')
            return cls(content)

    def dump(self, path: str):
        """
        Write an SSH signature to disk,

        Parameters:
        - path: the path where the SSH signature should be written

        Since the SSH signature in a WMAP file (and in this object) is in
        base64, we need to decode it before writing it to disk so that it
        matches the format which ssh-keygen expects.
        """
        with open(path, 'w') as f:
            decoded = str(base64.b64decode(self.content), 'utf-8')
            f.write(decoded)

    def __str__(self) -> str:
        return self.content


class SQSWrapper:  # pragma: no cover
    name: str
    region: str

    def __init__(self, region: str, name: str):
        import boto3  # type: ignore
        self.client = boto3.client('sqs', region_name=region)
        self.name = name
        self.region = region

    def receive(self, max_messages: int) -> List[dict]:
        response = self.client.receive_message(
            QueueUrl=self.name,
            MaxNumberOfMessages=max_messages,
            WaitTimeSeconds=20
        )
        return response.get('Messages', [])

    def delete(self, receipt_handle: str):
        self.client.delete_message(
            QueueUrl=self.name,
            ReceiptHandle=receipt_handle
        )

    def __repr__(self) -> str:
        return f"SQSWrapper({self.region}, {self.name})"


if __name__ == "__main__":  # pragma: no cover
    # This is a common Python trick.
    #
    # The `main` function is only called if this file is being run as a
    # *program* (in which case the global __name__ variable will be set to
    # "__main__"). If this file is being used as a library (which is the case
    # when we run the unit tests), `main` will not be called.
    main()
