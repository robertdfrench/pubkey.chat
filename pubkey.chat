#!/usr/bin/env python3
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
# Copyright 2024 Robert D. French
"""
The Web-based Message Authentication Protocol

WMAP allows secure exchange of signed messages between users using
their GitHub SSH keys. This tool allows you to sign, verify, and
extract messages.

Key features:
- Sign messages using SSH keys linked to GitHub accounts
- Verify the authenticity and integrity of signed messages
- Extract the content of signed messages

This module implements the core functionality of WMAP, including
command-line interface, cryptographic operations, and file handling.
"""
import argparse
import base64
import configparser
import contextlib
import curses
import dataclasses
import enum
import hashlib
import json
import os
import re
import subprocess
import tempfile
import threading
import time
import typing
import urllib
import urllib.request


# This is the hardcoded base URL for the pubkey.chat service. This
# will need to be configured, in the future, to default to
# `pubkey.chat` but also be overridable for the sake of testing.
API_BASE_URL = "https://pubkey.chat"


# Where we expect to find the config file if it has not otherwise been
# specified.
DEFAULT_CONFIG_PATH = "~/.config/pubkey.chat/config.ini"


# This is the SSH signing namespace that we use for wmap messages.
# This is to distinguish WMAP signatures from other SSH signin
# functions, as encouraged by the ssh-keygen(1) man page.
NAMESPACE = "wmap@wmap.dev"


def main():  # pragma: no cover
    """
    Application Entrypoint.

    This function is responsible for parsing the command line
    arguments and handing execution over to one of the subcommands
    ('chat' or 'daemon').

    Available command line arguments are describe below, but you can
    see them more easily by running `pubkey.chat -h`.
    """
    parser = argparse.ArgumentParser(
            description="Pubkey.Chat: You're already logged in!")

    # Create subparsers for each of the 'chat' and 'daemon' commands
    subparsers = parser.add_subparsers(
        dest='command',
        required=True,
        help='Subcommand to run')

    # Config Chat subcommand. This is what end users will invoke.
    chat_parser = subparsers.add_parser(
        'chat',
        help='Connect and start chatting!')
    chat_parser.add_argument(
        '--config',
        metavar='CONFIG',
        type=str,
        default=os.path.expanduser(DEFAULT_CONFIG_PATH),
        help=f"Chat config (defaults to f{DEFAULT_CONFIG_PATH})"
    )
    chat_parser.add_argument(
        'topic',
        type=str,
        help='Specify a topic for chat mode'
    )

    # Daemon subcommand. This is invoked by servers processing
    # incoming chat messages.
    daemon_parser = subparsers.add_parser(
        'daemon',
        help='Launch the backend service on your own infrastructure')
    daemon_parser.add_argument(
        '--config',
        metavar='CONFIG',
        type=str,
        required=True,
        help='Run the daemon with the specified config file'
    )

    # Parse the arguments provided by the user, according to the rules
    # laid out above.
    args = parser.parse_args()

    # Execute the corresponding function based on the subcommand
    if args.command == 'chat':
        chat_main(args.config, args.topic)
    elif args.command == 'daemon':
        daemon_main(args.config)


def chat_main(chat_config: str, topic: str):  # pragma: no cover
    """
    Open a chat window for 'topic'

    Parameters:
    - chat_config: path to a config file containing your GitHub
      username and the path to your SSH private key.
    - topic: The room you'd like to join
    """
    # If the config file doesn't already exist, prompt the user for
    # the information we need to create it.
    if not os.path.exists(chat_config):
        username = input("GitHub username: ")
        key_path = input("SSH Private key: ")
        ChatConfig(username, key_path).dump(chat_config)

    # Load the chat config from disk and extract the 'profile' and
    # 'private_key' objects which you'll need in order to sign your
    # chat messages.
    config = ChatConfig.load(chat_config)
    profile = Profile(config.username)
    private_key = PrivateKey(profile, config.key_path)

    # The curses library requires that we provide a function to
    # control our primary ui logic. And instance of the screen
    # (`stdscr`) is created by the curses library and passed as input
    # to this method, which will use it to steer the user experience.
    def chat_loop(stdscr):
        ptr = ChatPointer(topic)
        client = ChatAPIClient(API_BASE_URL, RestClient())
        ui = ChatUI(stdscr)
        subscription = TopicSubscription(topic, ui, ptr, client)

        # Run the TopicSubcscription logic in another thread. This
        # allows for new messages to appear on screen without causing
        # the ui to jitter.
        comms_thread = threading.Thread(target=subscription)
        comms_thread.daemon = True
        comms_thread.start()

        # Loop until the user quits the application. This loop waits
        # for user input, signing and posting that data once it is
        # available (when the user hits "Enter").
        while True:
            # Wait for input, and quit the application if the input is
            # the literal string "/quit".
            text = ui.wait_input()
            if text == "/quit":
                break

            # We have to assemble this in reverse order -- construct
            # an instance of InteriorMessage first, and then construct
            # a WMAP message by signing the InteriorMessage.
            imsg = ptr.new_interior_message(text)
            msg = private_key.sign_data(imsg.dumps().encode())

            # Try posting the message, and append a notice to the chat
            # buffer (visible only to the current user) if the message
            # could not be posted.
            try:
                client.post_message(msg)
            except urllib.error.HTTPError as e:
                ui.chatbuffer_add(f"[pubkey.chat]: {e}")

    # Start a curses window using the `chat_loop` method defined
    # above.
    curses.wrapper(chat_loop)


def daemon_main(config_path: str):  # pragma: no cover
    """
    Launch the chat service

    Parameters:
    - config_path: path to the chat service's config file

    The config file should spell out the AWS Region ('region'), name
    of an S3 bucket into which messages will be written
    ('bucket_name'), and the name of an SQS queue from which messages
    will be pulled ('queue_name').
    """
    # Load our AWS config options from `config_path`, and then create
    # clients for each AWS service we need: s3 (for storing messages),
    # sqs (for awaiting new messages), and DynamoDB (for synchronizing
    # access to topics among all the daemon hosts).
    config = DaemonConfig.load(config_path)
    s3 = S3Wrapper(config.region, config.bucket_name)
    lock_table = DynamoDBLock(config.region, config.table_name)
    lock = TopicLock(lock_table)
    bucket = PublicChatBucket(s3, lock)
    sqs = SQSWrapper(config.region, config.queue_name)
    queue = Queue(sqs)

    # For every message in the queue, attempt to validate it, and
    # write it to the message bucket if it's valid.
    for message in queue.messages():
        try:
            if message.is_valid():
                bucket.write_message(message)
        except Exception as e:
            print(f"Error: {e}")


@dataclasses.dataclass
class AuthorizedKey:
    """
    Representation of an Authorized Key entry, as seen in an
    ~/.ssh/authorized_keys file.

    See the AUTHORIZED_KEYS_FILE_FORMAT section of the sshd(8) man
    page for more information about what these files look like.
    """
    algorithm: 'SigningAlgorithm'
    material: str
    comment: str

    @classmethod
    def parse(cls, string: str) -> 'AuthorizedKey':
        """
        Parse an authorized keys entry into its constituent parts.
        Such entries take the following form:

            ssh-rsa ABC...123 username@example.com (other comments)

        Parameters:
        - string: a string which ought to be a normal-looking
          authorized keys entry.
        """
        parts = string.split()
        algorithm = SigningAlgorithm.parse(parts[0])
        return cls(algorithm, parts[1], " ".join(parts[2:]))

    def into_allowed_signer(self, profile: 'Profile') -> str:
        """
        Convert this authorized keys entry into an ALLOWED SIGNERS
        entry. Such records take the following form:

            username namespacs="wmap@wmap.dev" ssh-rsa ABC...123

        More information on ALLOWED SIGNERS can be found in the
        `ssh-keygen(1)` manual page.

        Parameters:
        - profile: the profile of the GitHub user for whom we'd like
          to build the ALLOWED SIGNERS record.
        """
        principal = profile.username
        algorithm = str(self.algorithm)
        material = self.material
        return " ".join([
            principal,
            f'namespaces="{NAMESPACE}"',
            algorithm,
            material
        ])


@dataclasses.dataclass
class ChatAPIClient:
    """
    Communication with the Pubkey.Chat backend. Updates messages,
    reads messages, and reads topics.
    """
    api_base_url: str
    rest_client: 'RestClient'

    def get_message(
            self,
            message_id: str) -> typing.Optional['SignedMessage']:
        """
        Get the signed message named `message_id` from the Pubkey.Chat
        backend. Re-validate locally to defend against a compromise of
        Pubkey.Chat. Returns None if message does not exist or is not
        valid.
        """
        url = f"{self.api_base_url}/messages/{message_id}"
        msg_text = self.rest_client.get(url)
        if msg_text:
            message = SignedMessage.loads(msg_text)
            if message.is_valid():
                return message
            else:
                return None
        else:
            return None

    def get_head(self, topic: str) -> str:
        """
        Get the id of the message most recently appended to `topic`.
        """
        url = f"{self.api_base_url}/topics/{topic}"
        response = self.rest_client.get(url)
        if not response:
            return ""
        if re.fullmatch(r'[0-9a-fA-F]{64}', response):
            # response is 64 hex chars
            return response
        else:
            return ""

    def post_message(self, message: 'SignedMessage') -> str:
        """
        Post a new message. If the message is valid, the Pubkey.chat
        backend service will make it available for download.
        Additionally, if it contains a chat-friendly 'InteriorMessage'
        which points to the current HEAD of the topic indicated in
        that message, the Pubkey.chat backend will update the topic
        HEAD so that this message will appear as part of the chat log.
        """
        url = f"{self.api_base_url}/messages"
        payload = message.into_dict()
        return self.rest_client.post_json(url, payload)


@dataclasses.dataclass
class ChatConfig:
    """
    This config file represents config options for the chat client.
    That means stuff like the username and the path to the user's
    preferred SSH private key (for signing messages).
    """
    username: str
    key_path: str

    @classmethod
    def load(cls, path: str) -> 'ChatConfig':
        """
        Load a config object from disk
        """
        config = configparser.ConfigParser()
        config.read(path)
        return cls(
            config['Credentials']['username'],
            config['Credentials']['key_path']
        )

    def dump(self, path: str):
        """
        Write a config object to disk
        """
        config = configparser.ConfigParser()
        config['Credentials'] = {
            'username': self.username,
            'key_path': self.key_path
        }
        dirname = os.path.dirname(path)

        # If `path` is in the current directory, `dirname` will be the
        # empty string. `os.makedirs` will not know what to do with
        # the empty string, so in this case we just replace it with
        # ".", which refers correctly to the current directory.
        if dirname == '':  # pragma: no cover
            dirname = "."

        os.makedirs(dirname, exist_ok=True)
        with open(path, 'w') as f:
            config.write(f)


@dataclasses.dataclass
class ChatPointer:
    """
    Reference to the current HEAD of the topic.
    """
    topic: str
    parent: str = ""

    def new_interior_message(self, text: str) -> 'InteriorMessage':
        """
        Create a new InteriorMessage object which refers to the HEAD
        of this topic. InteriorMessages which do not refer to HEAD
        will not be accepted by the Pubkey.Chat backend service.
        """
        return InteriorMessage(self.topic, self.parent, text)

    def update_parent(self, new_parent) -> bool:
        """
        Return true if the "new" parent is different than the current
        one. If it is different, retain it is the current parent. This
        is useful for updating state *and* checking if new work needs
        to be done, all in one motion.
        """
        if new_parent != self.parent:
            self.parent = new_parent
            return True
        return False


class ChatUI:  # pragma: no cover
    """
    This class comes from https://github.com/calzoneman/python-chatui
    and is licensed as follows:

    The MIT License (MIT)

    Copyright (c) 2013 Calvin Montgomery

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use, copy,
    modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
    """
    def __init__(self, stdscr):
        userlist_width = 16
        stdscr.clear()
        curses.use_default_colors()
        for i in range(0, curses.COLORS):
            curses.init_pair(i, i, -1)
        self.stdscr = stdscr
        self.userlist = []
        self.inputbuffer = ""
        self.linebuffer = []
        self.chatbuffer = []

        # Curses, why must you confuse me with your height, width, y,
        # x
        userlist_hwyx = (curses.LINES - 2, userlist_width - 1, 0, 0)
        chatbuffer_hwyx = (curses.LINES - 2,
                           curses.COLS-userlist_width-1,
                           0, userlist_width + 1)
        chatline_yx = (curses.LINES - 1, 0)
        self.win_userlist = stdscr.derwin(*userlist_hwyx)
        self.win_chatline = stdscr.derwin(*chatline_yx)
        self.win_chatbuffer = stdscr.derwin(*chatbuffer_hwyx)

        self.redraw_ui()

    def resize(self):
        """Handles a change in terminal size"""
        u_h, u_w = self.win_userlist.getmaxyx()
        h, w = self.stdscr.getmaxyx()

        self.win_chatline.mvwin(h - 1, 0)
        self.win_chatline.resize(1, w)

        self.win_userlist.resize(h - 2, u_w)
        self.win_chatbuffer.resize(h - 2, w - u_w - 2)

        self.linebuffer = []
        for msg in self.chatbuffer:
            self._linebuffer_add(msg)

        self.redraw_ui()

    def redraw_ui(self):
        """Redraws the entire UI"""
        h, w = self.stdscr.getmaxyx()
        u_h, u_w = self.win_userlist.getmaxyx()
        self.stdscr.clear()
        self.stdscr.vline(0, u_w + 1, "|", h - 2)
        self.stdscr.hline(h - 2, 0, "-", w)
        self.stdscr.refresh()

        self.redraw_userlist()
        self.redraw_chatbuffer()
        self.redraw_chatline()

    def redraw_chatline(self):
        """Redraw the user input textbox"""
        h, w = self.win_chatline.getmaxyx()
        self.win_chatline.clear()
        start = len(self.inputbuffer) - w + 1
        if start < 0:
            start = 0
        self.win_chatline.addstr(0, 0, self.inputbuffer[start:])
        self.win_chatline.refresh()

    def redraw_userlist(self):
        """Redraw the userlist"""
        self.win_userlist.clear()
        h, w = self.win_userlist.getmaxyx()
        for i, name in enumerate(self.userlist):
            if i >= h:
                break
            self.win_userlist.addstr(i, 0, name[:w - 1])
        self.win_userlist.refresh()

    def redraw_chatbuffer(self):
        """Redraw the chat message buffer"""
        self.win_chatbuffer.clear()
        h, w = self.win_chatbuffer.getmaxyx()
        j = len(self.linebuffer) - h
        if j < 0:
            j = 0
        for i in range(min(h, len(self.linebuffer))):
            self.win_chatbuffer.addstr(i, 0, self.linebuffer[j])
            j += 1
        self.win_chatbuffer.refresh()

    def chatbuffer_add(self, msg):
        """
        Add a message to the chat buffer, automatically slicing it to
        fit the width of the buffer
        """
        self.chatbuffer.append(msg)
        self._linebuffer_add(msg)
        self.redraw_chatbuffer()
        self.redraw_chatline()
        self.win_chatline.cursyncup()

    def _linebuffer_add(self, msg):
        h, w = self.stdscr.getmaxyx()
        u_h, u_w = self.win_userlist.getmaxyx()
        w = w - u_w - 2
        while len(msg) >= w:
            self.linebuffer.append(msg[:w])
            msg = msg[w:]
        if msg:
            self.linebuffer.append(msg)

    def prompt(self, msg):
        """Prompts the user for input and returns it"""
        self.inputbuffer = msg
        self.redraw_chatline()
        res = self.wait_input()
        res = res[len(msg):]
        return res

    def wait_input(self, prompt=""):
        """
        Wait for the user to input a message and hit enter.
        Returns the message
        """
        self.inputbuffer = prompt
        self.redraw_chatline()
        self.win_chatline.cursyncup()
        last = -1
        while last != ord('\n'):
            last = self.stdscr.getch()
            if last == ord('\n'):
                tmp = self.inputbuffer
                self.inputbuffer = ""
                self.redraw_chatline()
                self.win_chatline.cursyncup()
                return tmp[len(prompt):]
            elif last == curses.KEY_BACKSPACE or last == 127:
                if len(self.inputbuffer) > len(prompt):
                    self.inputbuffer = self.inputbuffer[:-1]
            elif last == curses.KEY_RESIZE:
                self.resize()
            elif 32 <= last <= 126:
                self.inputbuffer += chr(last)
            self.redraw_chatline()


@dataclasses.dataclass
class DaemonConfig:
    """
    Config file for the Message Validation Daemon. Contains the names
    of the AWS resources that we'll need to connect to.
    """
    region: str
    bucket_name: str
    table_name: str
    queue_name: str

    @classmethod
    def load(cls, path: str) -> 'DaemonConfig':
        """
        Load the daemon config from disk
        """
        config = configparser.ConfigParser()
        config.read(path)
        return cls(
            config['DEFAULT']['region'],
            config['DEFAULT']['bucket_name'],
            config['DEFAULT']['table_name'],
            config['DEFAULT']['queue_name']
        )


class DynamoDBLock:  # pragma: no cover
    """
    An expirable lock mechanism that relies on DynamoDB's conditional
    update capabilities.
    """
    def __init__(self, region: str, name: str):
        # We have to import boto3 here because we don't want to have
        # to import it at the top of this file, since it is necessary
        # for the chat client. Remember that one of the goals for the
        # chat client is to run without any dependencies beyond the
        # Python standard library.
        import boto3  # type: ignore
        self.dynamo = boto3.resource('dynamodb', region_name=region)
        self.table = self.dynamo.Table(name)

    def acquire(self, lock_id: str, ttl: int) -> bool:
        """
        Attempt to acquire a lock named `lock_id` for at least `ttl`
        seconds. If successful, no other worked will be able to get a
        lock for `lock_id` for the next `ttl` seconds, or whenever we
        release this lock (whichever comes first).
        """
        # This is the secret sauce. DynamoDB supports "condition
        # expressions" for updates, meaning that the update will not
        # proceed unless the following condition is met. In this case,
        # either there must not be any row for our chose `lock_id`, if
        # there is one, it must have already expired.
        cond_expr = 'attribute_not_exists(LockID) OR ExpiresAt < :now'
        now = int(time.time())
        expr_attr = {':now': now}
        item = {
            'LockID': lock_id,
            'ExpiresAt': now + ttl
        }
        try:
            # This update statement will only work if the condition
            # expression is true. If it is false, that means someone
            # else has the lock.
            self.table.put_item(
                Item=item,
                ConditionExpression=cond_expr,
                ExpressionAttributeValues=expr_attr
            )
            return True
        except Exception as e:
            print(e)
            return False

    def release(self, lock_id):
        # Release the lock by deleting the corresponding row from the
        # table.
        self.table.delete_item(Key={'LockID': lock_id})


@dataclasses.dataclass
class InteriorMessage:
    """
    This is the chat-oriented message which is signed, and placed
    inside a WMAP container (a SignedMessage object). It contains
    the message sent by the user, the topic to which they'd like to
    send the message, and the id of the current topic HEAD which
    should (hopefully) prove that the user has been paying attention.
    """
    topic: str
    parent: str
    text: str

    def into_dict(self) -> dict[str, str]:
        """
        helper function for `dumps`, below.
        """
        return {
                'topic': self.topic,
                'parent': self.parent,
                'text': self.text
        }

    def dumps(self) -> str:
        """
        Return a json-formatted string representing the contents of
        this object.
        """
        return json.dumps(self.into_dict())


@dataclasses.dataclass
class PrivateKey:
    """
    An SSH Private Key for the GitHub user identified by the `profile`
    object.
    """
    profile: 'Profile'
    path: str

    def sign(self, file: str):
        """
        Use this private key to sign the contents of `file`.

        Parameters:
        - file: the file (on disk) which should be signed

        Upon success, the signature will be stored in `file`.sig.
        """
        subprocess.run(
            [
                'ssh-keygen', '-Y', 'sign',
                '-f', self.path,
                '-n', NAMESPACE,
                file
            ],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL)

    def sign_data(
            self, data: bytes) -> 'SignedMessage':  # pragma: no cover
        """
        Like the `sign` method, but works on a "bytes" object instead
        of a file. This is handy if the data you'd like to sign
        resides in memory rather than on disk.
        """
        with tempfile.NamedTemporaryFile() as f:
            sigfile = f.name + ".sig"
            f.write(data)
            f.flush()
            self.sign(f.name)
            message = SignedMessage.from_raw_parts(
                    self.profile, f.name)
            os.remove(sigfile)
            return message


@dataclasses.dataclass
class Profile:
    """
    The GitHub profile associated with `username`
    """
    username: str

    def url(self) -> str:
        """URL for this user's github profile"""
        return f"https://github.com/{self.username}"

    def authorized_keys_url(self) -> str:
        """URL for this user's ssh public keys"""
        return self.url() + ".keys"

    def authorized_keys(self) -> typing.List[AuthorizedKey]:
        """
        Grab the user's Authorized Keys from GitHub, transforming each
        of them into an AuthorizedKey object.
        """
        url = self.authorized_keys_url()
        with urllib.request.urlopen(url) as response:
            lines = response.read().decode().splitlines()
            return [AuthorizedKey.parse(line) for line in lines]

    def allowed_signers(self) -> typing.List[str]:
        """
        Transform each Authorized Key into an ALLOWED SIGNERS record

        More information on ALLOWED SIGNERS can be found in the
        `ssh-keygen(1)` manual page.
        """
        keys = self.authorized_keys()
        return [k.into_allowed_signer(self) for k in keys]

    def verify_signed_data(
            self, data: bytes, signature_path: str) -> bool:
        """
        Check whether we have a valid signature for `data` from the
        current GitHub user.

        Parameters:
        - data: the bytes which were signed
        - signature_path: a path to the signature file created by
          ssh-keygen

        Returns true if the signature matches, false if not.
        """
        with tempfile.NamedTemporaryFile() as allowed_signers_file:
            signers = "\n".join(self.allowed_signers()) + "\n"
            # We write and flush together because we need to know for
            # sure that all these bytes have been written to disk
            # before we try to point ssh-keygen at this file.
            allowed_signers_file.write(bytes(signers, 'utf-8'))
            allowed_signers_file.flush()
            results = subprocess.run([
                'ssh-keygen', '-Y', 'verify',
                '-f', allowed_signers_file.name,
                '-I', self.username,
                '-n', NAMESPACE,
                '-s', signature_path
            ], input=data, capture_output=True)
            return results.returncode == 0

    def __str__(self) -> str:
        return self.username


@dataclasses.dataclass
class PublicChatBucket:
    """
    This class manages storage for all of the chat data. It stores
    signed messages, and manages synchronous updates to topic files.
    """
    s3: 'S3Wrapper'
    lock: 'TopicLock'

    def write_message(self, msg: 'SignedMessage'):
        """
        Write a new WMAP message to the bucket, updating message's
        topic if the following conditions are met:

        * No other worker has a lock for this topic
        * The message refers to the current topic HEAD (that is, the
          message is up-to-date)

        If the message refers to an older topic HEAD, then we assume
        that the user does not have all of the latest messages for
        this topic, so we do not allow them to append to the topic.

        Any code calling this function is expected to provide only
        messges which are calid. This function will not attempt to
        validate them.
        """
        msg_id = msg.digest()
        self.s3.write(f"messages/{msg_id}", msg.dumps())
        interior = msg.interior()
        with self.lock(interior.topic):
            # Now that we have acquired a lock for the topic, we can
            # try to update it.
            head = self.s3.read(f"topics/{interior.topic}")
            if not head:
                # No messages have been written to this topic yet, so
                # it's okay to make our message the first
                self.s3.write(f"topics/{interior.topic}", msg_id)
            if interior.parent == head:
                # Our message expects its parent to be the current
                # topic head, which means it's okay to make our
                # message the *new* topic head
                self.s3.write(f"topics/{interior.topic}", msg_id)


@dataclasses.dataclass
class Queue():
    """
    A generator of unverified WMAP messages.
    """
    sqs: 'SQSWrapper'

    def messages(self):
        """
        This is a generator, which can be used in a loop. Every
        unverified message is sent to the context of the loop, and is
        deleted afterwords. For example:

            for msg in queue.messages():
                print(msg.profile)

        This would print the author of each message, as soon as the
        message is visible in the queue, and would delete the message
        automatically before proceeding to the next message.
        """
        while True:
            # Get at most one message from the queue. If we get zero
            # messages, just try again -- there is a 20s delay, so
            # it's not like we are slamming SQS here.
            candidates = self.sqs.receive(1)
            if len(candidates) == 0:  # pragma: no cover
                continue

            # Hand our 1 message over to the loop body
            message = candidates[0]
            yield SignedMessage.from_dict(json.loads(message['Body']))

            # Delete the message from the queue so that it doesn't get
            # reprocessed.
            self.sqs.delete(message['ReceiptHandle'])


@dataclasses.dataclass
class RestClient:  # pragma: no cover
    """
    Nearly-raw (slightly-cooked?) HTTP requests to the Pubkey.Chat
    backend.
    """
    def get(self, url: str) -> typing.Optional[str]:
        """
        Issue an HTTP GET request for `url`.
        """
        with urllib.request.urlopen(url) as response:
            # The request will come back as a "bytes" object, so we
            # need to decode it, and remove any trailing whitespace.
            return response.read().decode().rstrip()

    def post_json(self, url: str, payload: dict) -> str:
        """
        POST a dictionary `payload` as JSON to `url`
        """
        data = json.dumps(payload).encode()
        headers = {'Content-Type': 'application/json'}
        r = urllib.request.Request(
                url, data=data, headers=headers, method='POST')
        with urllib.request.urlopen(r) as response:
            return response.read().decode()


class S3Wrapper:  # pragma: no cover
    """
    Storage access to S3. This wrapper is easier to mock than the S3
    client, since it only sports the subset of features that we need.

    In particular, we'll be doing these things:

    * Writing messages to /messages/{message_id}
    * Writing topics to /topics/{topic_name}
    * Reading topics from /topics/{topic_name}

    We won't be readying messages in this app; That is handled
    automatically by the API Gateway configuration.
    """
    def __init__(self, region: str, name: str):
        import boto3  # type: ignore
        self.client = boto3.client('s3', region_name=region)
        self.name = name

    def write(self, key: str, value: str):
        """
        Try store `value` at the bucket address given in `key`.
        """
        self.client.put_object(
            Bucket=self.name,
            Key=key,
            Body=value
        )

    def read(self, key: str) -> typing.Optional[str]:
        """
        Try to read a string from the bucket address given in `key`.
        """
        try:
            response = self.client.get_object(
                Bucket=self.name,
                Key=key
            )
            return response['Body'].read().decode()
        except Exception as e:
            print(e)
            return None


@dataclasses.dataclass
class Signature:
    """
    The output of ssh-keygen -Y sign
    """
    content: str

    @classmethod
    def load(cls, path: str) -> 'Signature':
        """
        Load an SSH signature from a file

        Parameters:
        - path: path to an SSH signature file

        The SSH signature is stored on disk in a format determined by
        OpenSSH.  This format is line-oriented, which is tricky to
        work with in a JSON document. As such, we choose to work with
        a base64-encoded representation of this signature instead.
        """
        with open(path) as f:
            raw_text = f.read()
            # Encode the signature bytes file as a Base64 string
            content = base64.b64encode(raw_text.encode()).decode()
            return cls(content)

    def dump(self, path: str):
        """
        Write an SSH signature to disk,

        Parameters:
        - path: the path where the SSH signature should be written

        Since the SSH signature in a WMAP file (and in this object) is
        in base64, we need to decode it before writing it to disk so
        that it matches the format which ssh-keygen expects.
        """
        with open(path, 'w') as f:
            decoded = base64.b64decode(self.content).decode()
            f.write(decoded)

    def __str__(self) -> str:
        return self.content


@dataclasses.dataclass
class SignedMessage:
    """
    A signed copy of the original content, which can be shared with
    and validated by anyone.
    """
    profile: 'Profile'
    body: bytes
    signature: 'Signature'

    @classmethod
    def from_raw_parts(
            cls, profile: 'Profile', path: str) -> 'SignedMessage':
        """
        Create a SignedMessage object from a file and its signature.

        Parameters:
        - profile: the GitHub profile of the user who signed this
          document
        - path: path to the document which was signed

        Assumptions:
        The document referenced by `path` should have been signed
        (using wmap) prior to calling this method. In particular, an
        OpenSSH-formatted signature file should exist on disk at
        `path`.sig.
        """
        with open(path, 'rb') as f:
            body = f.read()
        signature = Signature.load(path + ".sig")
        return cls(profile, body, signature)

    @classmethod
    def from_dict(cls, parts: dict[str, str]) -> 'SignedMessage':
        """
        Construct a new SignedMessage from a dictionary of `profile`,
        `body`, and `signature`. This will not verify the message, so
        if it is constructed out of junk, you will have a
        "SignedMessage" that isn't necessarily signed.
        """
        profile = Profile(parts['profile'])
        body = base64.b64decode(parts['body'].encode())
        signature = Signature(parts['signature'])
        return cls(profile, body, signature)

    @classmethod
    def load(cls, path: str) -> 'SignedMessage':
        """
        Load an existing JSON-formatted WMAP message from disk.

        Parameters:
        - path: path to the JSON-formatted WMAP message
        """
        with open(path) as f:
            return cls.loads(f.read())

    @classmethod
    def loads(cls, data: str) -> 'SignedMessage':
        """
        Load an existing JSON-formatted WMAP message from disk.

        Parameters:
        - path: path to the JSON-formatted WMAP message
        """
        d = json.loads(data)
        return cls.from_dict(d)

    def into_dict(self) -> dict[str, str]:
        """
        Convert this object into a python dictionary, and convert each
        of its fields into their string representation.
        """
        return {
            'profile': str(self.profile),
            'body': str(base64.b64encode(self.body), 'utf-8'),
            'signature': str(self.signature)
        }

    def dump(self, path: str):
        """
        Store this message on disk.

        Parameters:
        - path: path on disk where this JSON-formatted WMAP message
          should be written.
        """
        with open(path, 'w') as f:
            json.dump(self.into_dict(), f)

    def dumps(self) -> str:
        """
        Convert this message to a json string
        """
        return json.dumps(self.into_dict())

    def is_valid(self) -> bool:
        """
        Validate this message against the alleged author's GitHub
        public keys. If the message is not valid for any of the public
        keys *currently* available for the alleged author on GitHub,
        then we assume the message has been forged.

        A consequence of this decision is that once a public key has
        been removed from GitHub, messages signed with it will no
        longer be valid.
        """
        with tempfile.NamedTemporaryFile() as sigfile:
            self.signature.dump(sigfile.name)
            sigfile.flush()
            return self.profile.verify_signed_data(
                    self.body, sigfile.name)

    def interior(self) -> InteriorMessage:
        """
        Extract the "Interior" (or chat-oriented) message from the
        body of this message. Since the body of this message is a
        base64 bytes object, we can decode it to text and then load it
        as json.
        """
        i = json.loads(self.body.decode())
        if 'text' in i:
            text = i['text']
        else:  # pragma: no cover
            text = i['data']  # This is for old data
        return InteriorMessage(i['topic'], i['parent'], text)

    def digest(self) -> str:
        """
        Compute the sha256 hash of the entire message (not just the
        body!). This will serve as the id for the message.
        """
        digest = hashlib.sha256()
        digest.update(self.dumps().encode())
        return digest.hexdigest()


class SigningAlgorithm(enum.Enum):
    """
    Allowable algorithms for SSH signing keys.

    Not all SSH key algorithms support signing. RSA and ED25519 do, so
    when parsing an Allowed Signers record or an Authorized Key
    record, we want to restrict ourselves to those two algorithms.
    """
    RSA = enum.auto()
    ED25519 = enum.auto()

    @classmethod
    def parse(cls, string: str) -> 'SigningAlgorithm':
        """
        Attempt to parse a string into one of these SigningAlgorithm
        enum instances.

        Parameters:
        - string: a string which may or may not be a valid SSH signing
          algorithm.

        Raises:
        - Exception: if the string does not match an allowed
          algorithm.
        """
        if string == "ssh-rsa":
            return cls.RSA
        elif string == "ssh-ed25519":
            return cls.ED25519
        else:
            raise Exception("Unknown ssh key algorithm")

    def __str__(self):
        if self == SigningAlgorithm.RSA:
            return "ssh-rsa"
        if self == SigningAlgorithm.ED25519:
            return "ssh-ed25519"


class SQSWrapper:  # pragma: no cover
    """
    This is a minimal shim over the boto3 sqs client, which implements
    only the functionality we need in this app.
    """
    name: str
    region: str

    def __init__(self, region: str, name: str):
        import boto3  # type: ignore
        self.client = boto3.client('sqs', region_name=region)
        self.name = name
        self.region = region

    def receive(self, max_messages: int) -> typing.List[dict]:
        """
        Spend up to 20 seconds trying to receive up to `max_messages`.
        """
        response = self.client.receive_message(
            QueueUrl=self.name,
            MaxNumberOfMessages=max_messages,
            WaitTimeSeconds=20
        )
        return response.get('Messages', [])

    def delete(self, receipt_handle: str):
        """
        Acknowledge the message so that it doesn't show up in the
        queue again.
        """
        self.client.delete_message(
            QueueUrl=self.name,
            ReceiptHandle=receipt_handle
        )


@dataclasses.dataclass
class TopicLock:
    """
    An expirable lock for a single topic. Prevents other queue workers
    from modifying the same topic simultaneously.
    """
    lock_table: DynamoDBLock

    @contextlib.contextmanager
    def __call__(self, topic: str):
        """
        Run some code in the context of a lock. For example:

            with lock(topic):
                print(topic)

        This would prevent any other queue worker from printing the
        same topic at the same time. The lock is automatically
        acquired at the beginning of the "with" statement, and
        automatically released afterwards.
        """
        if not self.lock_table.acquire(topic, 2):
            raise Exception(f"Failed to acquire lock for {topic}")
        try:
            yield
        finally:
            self.lock_table.release(topic)


@dataclasses.dataclass
class TopicSubscription:  # pragma: no cover
    """
    Monitor a chat topic for changes. This work is done in a separate
    thread from the main curses interface so that the topic can be
    monitored without causing the interface to hang or jitter.
    """
    topic: str
    ui: 'ChatUI'
    ptr: 'ChatPointer'
    client: 'ChatAPIClient'

    def __call__(self):
        """
        Monitor a topic for changes, using exponential backoff when
        the topic is idle. This should allow for quick updates if the
        conversation is in motion, but also relax load on the backend
        if the conversation is idle.

        You may notice at this point the disadvantage of using HTTP
        polling over something more sophisticated like WebSockets.
        This tradeoff is made for simplicity of the client code.
        """
        e = 0
        while True:
            time.sleep(1.5 ** e)
            if self.update():
                # Something changed, so the conversation may be
                # active. Raise the polling frequency so that we get
                # new updates as soon as possible.
                e = 1
            else:
                # Nothing changed since the last time, so we decrease
                # the polling frequency in order to reduce load on the
                # pubkey.chat infrastructure. (Click 'Sponsor' on
                # https://github.com/robertdfrench/pubkey.chat to help
                # defray infrastructure costs! Thank you!!)
                if e <= 10:
                    e += 1

    def update(self) -> bool:
        """
        Check for updates to the topic. If there are updates, apply
        them to the user interface.

        It may help to remember here that topics are just text files
        that contain the id of the most recent message posted to that
        topic, just like a branch in git. So `head` and `parent`
        represent the message id contained in this topic file.
        """
        head = self.client.get_head(self.topic)
        if self.ptr.update_parent(head):
            message = self.client.get_message(self.ptr.parent)
            if message:
                username = message.profile.username
                text = message.interior().text
                self.ui.chatbuffer_add(f"{username}: {text}")
                return True
        return False


if __name__ == "__main__":  # pragma: no cover
    # This is a common Python trick.
    #
    # The `main` function is only called if this file is being run as
    # a *program* (in which case the global __name__ variable will be
    # set to "__main__"). If this file is being used as a library
    # (which is the case when we run the unit tests), `main` will not
    # be called.
    main()
