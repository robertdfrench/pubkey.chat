#!/usr/bin/env python3
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
# Copyright 2024 Robert D. French
"""
The Web-based Message Authentication Protocol

WMAP allows secure exchange of signed messages between users using
their GitHub SSH keys. This tool allows you to sign, verify, and
extract messages.

Key features:
- Sign messages using SSH keys linked to GitHub accounts
- Verify the authenticity and integrity of signed messages
- Extract the content of signed messages

This module implements the core functionality of WMAP, including
command-line interface, cryptographic operations, and file handling.
"""
import argparse
import base64
import configparser
import contextlib
import curses
import dataclasses
import enum
import hashlib
import json
import typing
import os
import urllib
import urllib.request
import re
import subprocess
import tempfile
import threading
import time


# This is the SSH signing namespace that we use for wmap messages.
# This is to distinguish WMAP signatures from other SSH signin
# functions, as encouraged by the ssh-keygen(1) man page.
NAMESPACE = "wmap@wmap.dev"


# This is the hardcoded base URL for the pubkey.chat service. This
# will need to be configured, in the future, to default to
# `pubkey.chat` but also be overridable for the sake of testing.
API_BASE_URL = "https://pubkey.chat"


# Where we expect to find the config file if it has not otherwise been
# specified.
DEFAULT_CONFIG_PATH = "~/.config/pubkey.chat/config.ini"


def main():  # pragma: no cover
    parser = argparse.ArgumentParser(
            description="Pubkey.Chat: You're already logged in!")

    # Create subparsers for the 'chat' and 'daemon' commands
    subparsers = parser.add_subparsers(
        dest='command',
        required=True,
        help='Subcommand to run')

    # Chat subcommand
    chat_parser = subparsers.add_parser(
        'chat',
        help='Connect and start chatting!')
    chat_parser.add_argument(
        '--config',
        metavar='CONFIG',
        type=str,
        default=os.path.expanduser(DEFAULT_CONFIG_PATH),
        help=f"Chat config (defaults to f{DEFAULT_CONFIG_PATH})"
    )
    chat_parser.add_argument(
        'topic',
        type=str,
        help='Specify a topic for chat mode'
    )

    # Daemon subcommand
    daemon_parser = subparsers.add_parser(
        'daemon',
        help='Launch the backend service on your own infrastructure')
    daemon_parser.add_argument(
        '--config',
        metavar='CONFIG',
        type=str,
        required=True,
        help='Run the daemon with the specified config file'
    )

    # Parse the arguments
    args = parser.parse_args()

    # Execute the corresponding function based on the subcommand
    if args.command == 'chat':
        chat_main(args.config, args.topic)
    elif args.command == 'daemon':
        daemon_main(args.config)


def chat_main(chat_config: str, topic: str):  # pragma: no cover
    """
    Open a chat window for 'topic'

    Parameters:
    - username: Your GitHub username
    - key: Path to your SSH private key
    - topic: The room you'd like to join
    """
    if not os.path.exists(chat_config):
        username = input("GitHub username: ")
        key_path = input("SSH Private key: ")
        ChatConfig(username, key_path).dump(chat_config)

    config = ChatConfig.load(chat_config)
    profile = Profile(config.username)
    private_key = PrivateKey(profile, config.key_path)

    def chat_loop(stdscr):
        ptr = ChatPointer(topic)
        client = ChatAPIClient(API_BASE_URL, RestClient())

        ui = ChatUI(stdscr, 16)
        ui.userlist.append(profile.username)
        subscription = TopicSubscription(topic, ui, ptr, client)

        comms_thread = threading.Thread(target=subscription)
        comms_thread.daemon = True
        comms_thread.start()

        while True:
            inp = ui.wait_input()
            if inp == "/quit":
                break
            imsg = ptr.new_interior_message(inp)
            msg = private_key.sign_data(imsg.dumps().encode())
            try:
                client.post_message(msg)
                subscription.reset_sleep_duration()
            except urllib.error.HTTPError as e:
                ui.chatbuffer_add(f"[pubkey.chat]: {e}")

    curses.wrapper(chat_loop)


def daemon_main(config_path: str):  # pragma: no cover
    """
    Launch the chat service

    Parameters:
    - config_path: path to the chat service's config file

    The config file should spell out the AWS Region ('region'), name
    of an S3 bucket into which messages will be written
    ('bucket_name'), and the name of an SQS queue from which messages
    will be pulled ('queue_name').
    """
    config = DaemonConfig.load(config_path)
    s3 = S3Wrapper(config.region, config.bucket_name)
    lock_table = DynamoDBLock(config.region, config.table_name)
    lock = TopicLock(lock_table)
    bucket = PublicChatBucket(s3, lock)
    sqs = SQSWrapper(config.region, config.queue_name)
    queue = Queue(sqs)
    for message in queue.messages():
        try:
            if message.is_valid():
                bucket.write_message(message)
        except Exception as e:
            print(f"Error: {e}")


INITIAL_SLEEP_DURATION = 0.1
MAX_SLEEP_DURATION = 30.0


@dataclasses.dataclass
class ChatConfig:
    username: str
    key_path: str

    @classmethod
    def load(cls, path: str) -> 'ChatConfig':
        config = configparser.ConfigParser()
        config.read(path)
        return cls(
            config['Credentials']['username'],
            config['Credentials']['key_path']
        )

    def dump(self, path: str):
        config = configparser.ConfigParser()
        config['Credentials'] = {
            'username': self.username,
            'key_path': self.key_path
        }
        dirname = os.path.dirname(path)
        if dirname == '':  # pragma: no cover
            dirname = "."
        os.makedirs(dirname, exist_ok=True)
        with open(path, 'w') as f:
            config.write(f)


@dataclasses.dataclass
class DaemonConfig:
    region: str
    bucket_name: str
    table_name: str
    queue_name: str

    @classmethod
    def load(cls, path: str) -> 'DaemonConfig':
        config = configparser.ConfigParser()
        config.read(path)
        return cls(
            config['DEFAULT']['region'],
            config['DEFAULT']['bucket_name'],
            config['DEFAULT']['table_name'],
            config['DEFAULT']['queue_name']
        )


@dataclasses.dataclass
class TopicSubscription:  # pragma: no cover
    topic: str
    ui: 'ChatUI'
    ptr: 'ChatPointer'
    client: 'ChatAPIClient'
    sleep_duration: float = INITIAL_SLEEP_DURATION

    def __call__(self):
        while True:
            time.sleep(self.sleep_duration)
            self.work()

    def reset_sleep_duration(self):
        self.sleep_duration = INITIAL_SLEEP_DURATION

    def work(self):
        head = self.client.get_head(self.topic)
        if self.ptr.update_parent(head):
            message = self.client.get_message(self.ptr.parent)
            username = message.profile.username
            text = message.interior().text
            self.ui.chatbuffer_add(f"{username}: {text}")
            self.reset_sleep_duration()
        else:
            if self.sleep_duration < MAX_SLEEP_DURATION:
                self.sleep_duration *= 2


class ChatUI:  # pragma: no cover
    """
    This class comes from https://github.com/calzoneman/python-chatui
    and is licensed as follows:

    The MIT License (MIT)

    Copyright (c) 2013 Calvin Montgomery

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use, copy,
    modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
    """
    def __init__(self, stdscr, userlist_width=16):
        stdscr.clear()
        curses.use_default_colors()
        for i in range(0, curses.COLORS):
            curses.init_pair(i, i, -1)
        self.stdscr = stdscr
        self.userlist = []
        self.inputbuffer = ""
        self.linebuffer = []
        self.chatbuffer = []

        # Curses, why must you confuse me with your height, width, y,
        # x
        userlist_hwyx = (curses.LINES - 2, userlist_width - 1, 0, 0)
        chatbuffer_hwyx = (curses.LINES - 2,
                           curses.COLS-userlist_width-1,
                           0, userlist_width + 1)
        chatline_yx = (curses.LINES - 1, 0)
        self.win_userlist = stdscr.derwin(*userlist_hwyx)
        self.win_chatline = stdscr.derwin(*chatline_yx)
        self.win_chatbuffer = stdscr.derwin(*chatbuffer_hwyx)

        self.redraw_ui()

    def resize(self):
        """Handles a change in terminal size"""
        u_h, u_w = self.win_userlist.getmaxyx()
        h, w = self.stdscr.getmaxyx()

        self.win_chatline.mvwin(h - 1, 0)
        self.win_chatline.resize(1, w)

        self.win_userlist.resize(h - 2, u_w)
        self.win_chatbuffer.resize(h - 2, w - u_w - 2)

        self.linebuffer = []
        for msg in self.chatbuffer:
            self._linebuffer_add(msg)

        self.redraw_ui()

    def redraw_ui(self):
        """Redraws the entire UI"""
        h, w = self.stdscr.getmaxyx()
        u_h, u_w = self.win_userlist.getmaxyx()
        self.stdscr.clear()
        self.stdscr.vline(0, u_w + 1, "|", h - 2)
        self.stdscr.hline(h - 2, 0, "-", w)
        self.stdscr.refresh()

        self.redraw_userlist()
        self.redraw_chatbuffer()
        self.redraw_chatline()

    def redraw_chatline(self):
        """Redraw the user input textbox"""
        h, w = self.win_chatline.getmaxyx()
        self.win_chatline.clear()
        start = len(self.inputbuffer) - w + 1
        if start < 0:
            start = 0
        self.win_chatline.addstr(0, 0, self.inputbuffer[start:])
        self.win_chatline.refresh()

    def redraw_userlist(self):
        """Redraw the userlist"""
        self.win_userlist.clear()
        h, w = self.win_userlist.getmaxyx()
        for i, name in enumerate(self.userlist):
            if i >= h:
                break
            self.win_userlist.addstr(i, 0, name[:w - 1])
        self.win_userlist.refresh()

    def redraw_chatbuffer(self):
        """Redraw the chat message buffer"""
        self.win_chatbuffer.clear()
        h, w = self.win_chatbuffer.getmaxyx()
        j = len(self.linebuffer) - h
        if j < 0:
            j = 0
        for i in range(min(h, len(self.linebuffer))):
            self.win_chatbuffer.addstr(i, 0, self.linebuffer[j])
            j += 1
        self.win_chatbuffer.refresh()

    def chatbuffer_add(self, msg):
        """
        Add a message to the chat buffer, automatically slicing it to
        fit the width of the buffer
        """
        self.chatbuffer.append(msg)
        self._linebuffer_add(msg)
        self.redraw_chatbuffer()
        self.redraw_chatline()
        self.win_chatline.cursyncup()

    def _linebuffer_add(self, msg):
        h, w = self.stdscr.getmaxyx()
        u_h, u_w = self.win_userlist.getmaxyx()
        w = w - u_w - 2
        while len(msg) >= w:
            self.linebuffer.append(msg[:w])
            msg = msg[w:]
        if msg:
            self.linebuffer.append(msg)

    def prompt(self, msg):
        """Prompts the user for input and returns it"""
        self.inputbuffer = msg
        self.redraw_chatline()
        res = self.wait_input()
        res = res[len(msg):]
        return res

    def wait_input(self, prompt=""):
        """
        Wait for the user to input a message and hit enter.
        Returns the message
        """
        self.inputbuffer = prompt
        self.redraw_chatline()
        self.win_chatline.cursyncup()
        last = -1
        while last != ord('\n'):
            last = self.stdscr.getch()
            if last == ord('\n'):
                tmp = self.inputbuffer
                self.inputbuffer = ""
                self.redraw_chatline()
                self.win_chatline.cursyncup()
                return tmp[len(prompt):]
            elif last == curses.KEY_BACKSPACE or last == 127:
                if len(self.inputbuffer) > len(prompt):
                    self.inputbuffer = self.inputbuffer[:-1]
            elif last == curses.KEY_RESIZE:
                self.resize()
            elif 32 <= last <= 126:
                self.inputbuffer += chr(last)
            self.redraw_chatline()


class SigningAlgorithm(enum.Enum):
    """
    Allowable algorithms for SSH signing keys.

    Not all SSH key algorithms support signing. RSA and ED25519 do, so
    when parsing an Allowed Signers record or an Authorized Key
    record, we want to restrict ourselves to those two algorithms.
    """
    RSA = enum.auto()
    ED25519 = enum.auto()

    @classmethod
    def parse(cls, string: str) -> 'SigningAlgorithm':
        """
        Attempt to parse a string into one of these SigningAlgorithm
        enum instances.

        Parameters:
        - string: a string which may or may not be a valid SSH signing
          algorithm.

        Raises:
        - Exception: if the string does not match an allowed
          algorithm.
        """
        if string == "ssh-rsa":
            return cls.RSA
        elif string == "ssh-ed25519":
            return cls.ED25519
        else:
            raise Exception("Unknown ssh key algorithm")

    def __str__(self):
        if self == SigningAlgorithm.RSA:
            return "ssh-rsa"
        if self == SigningAlgorithm.ED25519:
            return "ssh-ed25519"


@dataclasses.dataclass
class AuthorizedKey:
    """
    Representation of an Authorized Key entry, as seen in an
    ~/.ssh/authorized_keys file.

    See the AUTHORIZED_KEYS_FILE_FORMAT section of the sshd(8) man
    page for more information about what these files look like.
    """
    algorithm: SigningAlgorithm
    material: str
    comment: str

    @classmethod
    def parse(cls, string: str) -> 'AuthorizedKey':
        """
        Parse an authorized keys entry into its constituent parts.
        Such entries take the following form:

            ssh-rsa ABC...123 username@example.com (other comments)

        Parameters:
        - string: a string which ought to be a normal-looking
          authorized keys entry.
        """
        parts = string.split()
        algorithm = SigningAlgorithm.parse(parts[0])
        return cls(algorithm, parts[1], " ".join(parts[2:]))

    def into_allowed_signer(self, profile: 'Profile') -> str:
        """
        Convert this authorized keys entry into an ALLOWED SIGNERS
        entry. Such records take the following form:

            username namespacs="wmap@wmap.dev" ssh-rsa ABC...123

        More information on ALLOWED SIGNERS can be found in the
        `ssh-keygen(1)` manual page.

        Parameters:
        - profile: the profile of the GitHub user for whom we'd like
          to build the ALLOWED SIGNERS record.
        """
        principal = profile.username
        algorithm = str(self.algorithm)
        material = self.material
        return " ".join([
            principal,
            f'namespaces="{NAMESPACE}"',
            algorithm,
            material
        ])


@dataclasses.dataclass
class PublicChatBucket:
    s3: 'S3Wrapper'
    lock: 'TopicLock'

    def write_message(self, msg: 'SignedMessage'):
        msg_id = msg.digest()
        self.s3.write(f"messages/{msg_id}", msg.dumps())
        interior = msg.interior()
        with self.lock(interior.topic):
            head = self.s3.read(f"topics/{interior.topic}")
            if not head:
                self.s3.write(f"topics/{interior.topic}", msg_id)
            if interior.parent == head:
                self.s3.write(f"topics/{interior.topic}", msg_id)


class DynamoDBLock:  # pragma: no cover
    def __init__(self, region: str, name: str):
        import boto3  # type: ignore
        self.dynamo = boto3.resource('dynamodb', region_name=region)
        self.table = self.dynamo.Table(name)

    def acquire(self, lock_id: str, ttl: int):
        now = int(time.time())
        cond_expr = 'attribute_not_exists(LockID) OR ExpiresAt < :now'
        expr_attr = {':now': now}
        item = {
            'LockID': lock_id,
            'ExpiresAt': now + ttl
        }
        try:
            self.table.put_item(
                Item=item,
                ConditionExpression=cond_expr,
                ExpressionAttributeValues=expr_attr
            )
            return True
        except Exception as e:
            print(e)
            return False

    def release(self, lock_id):
        self.table.delete_item(Key={'LockID': lock_id})


@dataclasses.dataclass
class ChatAPIClient:
    """
    Raw operations with the Chat Service backend
    """
    api_base_url: str
    rest_client: 'RestClient'

    def get_message(
            self,
            message_id: str) -> typing.Optional['SignedMessage']:
        url = f"{self.api_base_url}/messages/{message_id}"
        msg_text = self.rest_client.get(url)
        if msg_text:
            return SignedMessage.loads(msg_text)
        else:
            return None

    def get_head(self, topic: str) -> str:
        url = f"{self.api_base_url}/topics/{topic}"
        response = self.rest_client.get(url)
        if not response:
            return ""
        if re.fullmatch(r'[0-9a-fA-F]{64}', response):
            # response is 64 hex chars
            return response
        else:
            return ""

    def post_message(self, message: 'SignedMessage') -> str:
        url = f"{self.api_base_url}/messages"
        payload = message.into_dict()
        return self.rest_client.post_json(url, payload)


@dataclasses.dataclass
class InteriorMessage:
    topic: str
    parent: str
    text: str

    def into_dict(self) -> dict[str, str]:
        return {
                'topic': self.topic,
                'parent': self.parent,
                'text': self.text
        }

    def dumps(self) -> str:
        return json.dumps(self.into_dict())


@dataclasses.dataclass
class SignedMessage:
    """
    A signed copy of the original content, which can be shared with
    and validated by anyone.
    """
    profile: 'Profile'
    body: bytes
    signature: 'Signature'

    @classmethod
    def from_raw_parts(
            cls, profile: 'Profile', path: str) -> 'SignedMessage':
        """
        Create a SignedMessage object from a file and its signature.

        Parameters:
        - profile: the GitHub profile of the user who signed this
          document
        - path: path to the document which was signed

        Assumptions:
        The document referenced by `path` should have been signed
        (using wmap) prior to calling this method. In particular, an
        OpenSSH-formatted signature file should exist on disk at
        `path`.sig.
        """
        with open(path, 'rb') as f:
            body = f.read()
        signature = Signature.load(path + ".sig")
        return cls(profile, body, signature)

    @classmethod
    def from_dict(cls, parts: dict[str, str]) -> 'SignedMessage':
        profile = Profile(parts['profile'])
        body = base64.b64decode(parts['body'].encode())
        signature = Signature(parts['signature'])
        return cls(profile, body, signature)

    @classmethod
    def load(cls, path: str) -> 'SignedMessage':
        """
        Load an existing JSON-formatted WMAP message from disk.

        Parameters:
        - path: path to the JSON-formatted WMAP message
        """
        with open(path) as f:
            return cls.loads(f.read())

    @classmethod
    def loads(cls, data: str) -> 'SignedMessage':
        """
        Load an existing JSON-formatted WMAP message from disk.

        Parameters:
        - path: path to the JSON-formatted WMAP message
        """
        d = json.loads(data)
        return cls.from_dict(d)

    def into_dict(self) -> dict[str, str]:
        """
        Convert this object into a python dictionary, and convert each
        of its fields into their string representation.
        """
        return {
            'profile': str(self.profile),
            'body': str(base64.b64encode(self.body), 'utf-8'),
            'signature': str(self.signature)
        }

    def dump(self, path: str):
        """
        Store this message on disk.

        Parameters:
        - path: path on disk where this JSON-formatted WMAP message
          should be written.
        """
        with open(path, 'w') as f:
            json.dump(self.into_dict(), f)

    def dumps(self) -> str:
        """
        Convert this message to a json string
        """
        return json.dumps(self.into_dict())

    def is_valid(self) -> bool:
        with tempfile.NamedTemporaryFile() as sigfile:
            self.signature.dump(sigfile.name)
            sigfile.flush()
            return self.profile.verify_signed_data(
                    self.body, sigfile.name)

    def interior(self) -> InteriorMessage:
        i = json.loads(self.body.decode())
        if 'text' in i:
            text = i['text']
        else:  # pragma: no cover
            text = i['data']  # This is for old data
        return InteriorMessage(i['topic'], i['parent'], text)

    def digest(self) -> str:
        digest = hashlib.sha256()
        digest.update(self.dumps().encode())
        return digest.hexdigest()


@dataclasses.dataclass
class Profile:
    """
    The GitHub profile associated with `username`
    """
    username: str

    def url(self) -> str:
        """URL for this user's github profile"""
        return f"https://github.com/{self.username}"

    def authorized_keys_url(self) -> str:
        """URL for this user's ssh public keys"""
        return self.url() + ".keys"

    def authorized_keys(self) -> typing.List[AuthorizedKey]:
        """
        Grab the user's Authorized Keys from GitHub, transforming each
        of them into an AuthorizedKey object.
        """
        with urllib.request.urlopen(self.authorized_keys_url()) as response:
            lines = response.read().decode().splitlines()
            return [AuthorizedKey.parse(line) for line in lines]

    def allowed_signers(self) -> typing.List[str]:
        """
        Transform each Authorized Key into an ALLOWED SIGNERS record

        More information on ALLOWED SIGNERS can be found in the
        `ssh-keygen(1)` manual page.
        """
        keys = self.authorized_keys()
        return [k.into_allowed_signer(self) for k in keys]

    def verify_signed_data(
            self, data: bytes, signature_path: str) -> bool:
        """
        Check whether we have a valid signature for `data` from the
        current GitHub user.

        Parameters:
        - data: the bytes which were signed
        - signature_path: a path to the signature file created by
          ssh-keygen

        Returns true if the signature matches, false if not.
        """
        with tempfile.NamedTemporaryFile() as allowed_signers_file:
            signers = "\n".join(self.allowed_signers()) + "\n"
            # We write and flush together because we need to know for
            # sure that all these bytes have been written to disk
            # before we try to point ssh-keygen at this file.
            allowed_signers_file.write(bytes(signers, 'utf-8'))
            allowed_signers_file.flush()
            results = subprocess.run([
                'ssh-keygen', '-Y', 'verify',
                '-f', allowed_signers_file.name,
                '-I', self.username,
                '-n', NAMESPACE,
                '-s', signature_path
            ], input=data, capture_output=True)
            return results.returncode == 0

    def __str__(self) -> str:
        return self.username


@dataclasses.dataclass
class PrivateKey:
    """
    An SSH Private Key for the GitHub user identified by the `profile`
    object.
    """
    profile: Profile
    path: str

    def sign(self, file: str):
        """
        Use this private key to sign the contents of `file`.

        Parameters:
        - file: the file (on disk) which should be signed

        Upon success, the signature will be stored in `file`.sig.
        """
        subprocess.run(
            [
                'ssh-keygen', '-Y', 'sign',
                '-f', self.path,
                '-n', NAMESPACE,
                file
            ],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL)

    def sign_data(
            self, data: bytes) -> SignedMessage:  # pragma: no cover
        with tempfile.NamedTemporaryFile() as f:
            sigfile = f.name + ".sig"
            f.write(data)
            f.flush()
            self.sign(f.name)
            message = SignedMessage.from_raw_parts(
                    self.profile, f.name)
            os.remove(sigfile)
            return message


@dataclasses.dataclass
class Queue():
    sqs: 'SQSWrapper'

    def messages(self):
        while True:
            candidates = self.sqs.receive(1)
            if len(candidates) == 0:  # pragma: no cover
                continue
            message = candidates[0]
            yield SignedMessage.from_dict(json.loads(message['Body']))
            self.sqs.delete(message['ReceiptHandle'])


@dataclasses.dataclass
class RestClient:  # pragma: no cover
    def get(self, url: str) -> typing.Optional[str]:
        with urllib.request.urlopen(url) as response:
            return response.read().decode().rstrip()

    def post_json(self, url: str, payload: dict) -> str:
        data = json.dumps(payload).encode()
        headers = {'Content-Type': 'application/json'}
        r = urllib.request.Request(
                url, data=data, headers=headers, method='POST')
        with urllib.request.urlopen(r) as response:
            return response.read().decode()


class S3Wrapper:  # pragma: no cover
    def __init__(self, region, name):
        import boto3  # type: ignore
        self.client = boto3.client('s3', region_name=region)
        self.name = name

    def write(self, key: str, value: str):
        self.client.put_object(
            Bucket=self.name,
            Key=key,
            Body=value
        )

    def read(self, key: str) -> typing.Optional[str]:
        try:
            response = self.client.get_object(
                Bucket=self.name,
                Key=key
            )
            return response['Body'].read().decode()
        except Exception as e:
            print(e)
            return None


@dataclasses.dataclass
class TopicLock:
    lock_table: DynamoDBLock

    @contextlib.contextmanager
    def __call__(self, topic: str):
        if not self.lock_table.acquire(topic, 2):
            raise Exception(f"Failed to acquire lock for {topic}")
        try:
            yield
        finally:
            self.lock_table.release(topic)


class ChatPointer:
    topic: str
    parent: str

    def __init__(self, topic: str):
        self.topic = topic
        self.parent = ""

    def new_interior_message(self, text: str) -> InteriorMessage:
        return InteriorMessage(self.topic, self.parent, text)

    def update_parent(self, new_parent) -> bool:
        if new_parent != self.parent:
            self.parent = new_parent
            return True
        return False


@dataclasses.dataclass
class Signature:
    """
    The output of ssh-keygen -Y sign
    """
    content: str

    @classmethod
    def load(cls, path: str) -> 'Signature':
        """
        Load an SSH signature from a file

        Parameters:
        - path: path to an SSH signature file

        The SSH signature is stored on disk in a format determined by
        OpenSSH.  This format is line-oriented, which is tricky to
        work with in a JSON document. As such, we choose to work with
        a base64-encoded representation of this signature instead.
        """
        with open(path) as f:
            raw_text = f.read()
            # Encode the signature bytes file as a Base64 string
            content = base64.b64encode(raw_text.encode()).decode()
            return cls(content)

    def dump(self, path: str):
        """
        Write an SSH signature to disk,

        Parameters:
        - path: the path where the SSH signature should be written

        Since the SSH signature in a WMAP file (and in this object) is
        in base64, we need to decode it before writing it to disk so
        that it matches the format which ssh-keygen expects.
        """
        with open(path, 'w') as f:
            decoded = base64.b64decode(self.content).decode()
            f.write(decoded)

    def __str__(self) -> str:
        return self.content


class SQSWrapper:  # pragma: no cover
    name: str
    region: str

    def __init__(self, region: str, name: str):
        import boto3  # type: ignore
        self.client = boto3.client('sqs', region_name=region)
        self.name = name
        self.region = region

    def receive(self, max_messages: int) -> typing.List[dict]:
        response = self.client.receive_message(
            QueueUrl=self.name,
            MaxNumberOfMessages=max_messages,
            WaitTimeSeconds=20
        )
        return response.get('Messages', [])

    def delete(self, receipt_handle: str):
        self.client.delete_message(
            QueueUrl=self.name,
            ReceiptHandle=receipt_handle
        )

    def __repr__(self) -> str:
        return f"SQSWrapper({self.region}, {self.name})"


if __name__ == "__main__":  # pragma: no cover
    # This is a common Python trick.
    #
    # The `main` function is only called if this file is being run as
    # a *program* (in which case the global __name__ variable will be
    # set to "__main__"). If this file is being used as a library
    # (which is the case when we run the unit tests), `main` will not
    # be called.
    main()
